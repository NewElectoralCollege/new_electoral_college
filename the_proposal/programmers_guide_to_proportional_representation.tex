\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{coding}{  
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,   
    keepspaces=true,
    numbers=left,   
    numbersep=5pt, 
    showspaces=false,       
    showstringspaces=false,
    showtabs=false, 
    tabsize=1
}

% Coding examples can be found here: https://github.com/KingWither/new_electoral_college/tree/main/the_proposal/programming_examples

\lstset{style=coding}

\title{A Programmer's Guide to Proportional Representation}
\author{David G. Boers}

\begin{document}
    \maketitle
    This document contains some computer code that calculates Proportional Representation. It also contains explinations of the code, and some thoughs as to why that language is the best for different uses. 
    
    \section{C/C++}
    C is probably the best language to use for Proportional Representation if you are creating an application that needs to run PR calculations repeatedly. For instance, doing analysis on PR, or forcasting results requires processing a lot of elections. 

    \lstinputlisting[language=C]{programming_examples/c.txt}

    The C++ implementation can be a little simpler. It is much easier to import data, and the arrays can be consolidated. In my expirence it is also faster.

    \lstinputlisting[language=C++]{programming_examples/c++.txt}

    \section{Python}

    Python will likley be the most effective way of running a PR election. It's simple syntax and huge library makes it easy for newer programmers to understand.

    \lstinputlisting[language=Python]{programming_examples/python.txt}

    Notice how the Python example has the smallest number of lines; 26. C needed 42, and C++ needed 66.

    \section{PHP}

    It is very simple to connect a PHP program to another language. If you are creating a webapp, PHP may be the best option if you don't plan to use eRuby to create HTML. PHP is actually a server-scripting language, so it could be used on a server as well. 

    \lstinputlisting[language=PHP]{programming_examples/php.txt}

    \section{Ruby}

    If you are going to use eRuby, are on a Ruby on Rails server, or just prefer Ruby's syntax, the language will probably get the job done as well as PHP.

    \lstinputlisting[language=Ruby]{programming_examples/ruby.txt}

    \section{Haskell}

    The fact that Haskell's values are immutable makes it difficult to handle certain variables in PR. Instead of using a single \texttt{seats} variable, a separate boolean called \verb|extra_seat| can be used.

    \lstinputlisting[language=Haskell]{programming_examples/haskell_workaround.txt}
    
    Here is the complete Haskell implementation:

    \lstinputlisting[language=Haskell]{programming_examples/haskell.txt}

    \section{Object Oriented Programming}

    Object Oriented languages have an advantage over functional ones when it comes to calculating PR. Classes can easily hold large numbers of parties, each with many extra variables. This is helpfull when it comes to party lists. See the following C++ example:

    \lstinputlisting[language=C++]{programming_examples/object_oriented.txt}

    Haskell's types can help with this two:

    \lstinputlisting[language=Haskell]{programming_examples/haskell_records.txt}

    although the fact that Haskell records can't contain functions like C++ or Ruby can makes this much more complex. 

    \section{Lists}

    Be carefull with Party Lists. Storing a list of 5 candidates for 5 parties is 25 names, but if you have 50 seats, and 20-30 parties, you are going to have a ton of candidates. This takes up a lot of memory, and in some languages that can get to be highly impractical. The following example only takes the names from the \verb|list.txt| file that it needs.

    \lstinputlisting[language=C++]{programming_examples/getClosedList.txt}

    However, it isn't always this simple. Open Lists, for example, require the analysis of all candidates.

    \lstinputlisting[language=C++]{programming_examples/getOpenList.txt}

\end{document}